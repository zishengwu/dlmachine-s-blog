# 一 传统方法

之前的文章已经介绍过向量数据库在RAG（Retrieval Augmented Generative）中的应用，本文将会讨论另一个重要的工具-Embedding模型。
![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25170e926d4544e1aa376df1bf0770be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080\&h=724\&s=129393\&e=png\&b=fefefe)一般来说，构建生产环境下的RAG系统是直接使用Embedding模型对用户输入的Query进行向量化表示，并且从已经构建好的向量数据库中检索出相关的段落用户大模型生成。但是这种方法很明显会受到Embedding模型性能的影响，比如是否支持多语言、跨语言检索、训练数据的质量等。因此，以改进Embedding模型为目标提升RAG系统性能一般会有两种做法：

方法1，在使用向量模型获取密集向量后，再使用Cross-encoder作为精排模型，对第一次召回的结果进行重排，以提高最终结果的质量。
方法2，使用稀疏向量搭配密集向量进行召回。密集向量即对整个文本进行向量化表示产生的向量，稀疏向量则是对原始文本的编码表示，如TF-IDF，BM25等。其中，稀疏向量可以帮助识别和捕捉特定的语义信息，比如文本中的关键词，而密集向量则可以提供更丰富的语义表达，是通过大量长文本学习而来的。通过同时将这两种向量进行召回，可以获得更丰富、更全面的信息，从而提升 RAG 的效果。

方法1和方法2既可以独立使用，也可以搭配使用，这就大大增加了算法工程师的武器库，通过搭积木的方式来提高RAG系统的效果。

# 二 Reranker模型剖析

本文主要讨论二阶段检索的方法，对于稀疏向量的讨论不在本文范围之内。

## 使用精排模型的原因

原因之一，向量数据库中存储大量的向量数据，而想要从大量数据中精确地检索出最相似的向量势必会带来极大的延迟，这在任何应用中都是无法接受的，因此向量数据库一般都会通过建立索引来优化查找过程，这实际上是一种**近似检索**而非精确检索，是准确与效率的折衷方案。如果数据库中没有那么多的向量，或者全表检索的时间损耗能够接受，则完全没必要用近似检索，但这在实际生产系统中是不可能的。

其二，LLM受限于上下文长度的限制，所以能利用到的向量片段数量是有限的，尽管现在越来越多的研究使得LLM的上下文窗口越来越长，如改进位置编码或者注意力机制等，但也有实验表明再长的上下文输入给大模型总会由遗失或者处理不好的情况，称为“Lost in middle”现象。因此，更好的办法是把更有用的上下文筛选出来，重点在于提升质而不是量。

## 精排模型结构

下面有两个模型，分别是Bi-Encoder和Cross-Encoder。左边的Bi-Encoder实际上就是我们常见的向量化模型，需要注意的是模型的结构并不是有2个Bert，而是只有1个Bert模型，但是对于两个句子分别做了向量化表示，最终比较这两个向量的相似度。**这里‘Bi’表示的是处理的过程，而不是实际的结构**。

![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f5fdcb507f74ba4a94aee08d791801a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=479\&h=267\&s=24147\&e=png\&b=fefefe)

而精排模型用到的Cross-Encoder结构则是把两个句子的输入concat到一起，最终预测这两个句子是否相关，有点类似于Bert训练时的next sentence prediction（NSP）。不难发现，这实际上就是一个分类模型，而且并不会产生具体的向量表示，只会产生一个介于0和1之间的值，用于表示句子对的相似性。而且，在使用时，需要将Query与待查询的句子拼接到一起再输入给模型，所以这就决定了输入的句子对数量不能太多，否则带来的计算耗时将会是无法估量的。

## 精排模型的本质

直观上来讲，用Bi-Encoder“目的更加通用”，是为了得到输入的向量化表示，这些向量不仅有大小，还有方向，因此就有这么一个学习向量化时遇到的经典例子：$国王-男人=女王-女人$。

而使用了Cross-Encoder的精排模型，因为输入部分包含了两个原始的句子，因此是从文本空间直接表示句子的相似度，而不是到了向量空间再表示。具体而言就是：传统的向量是经过了模型输出之后再根据不同的算子计算向量之间的相似度，而这个模型是句子对由模型得到端到端的结果。

**能否再使用一次向量比较？或者说一阶段后再对检索出的向量计算精确的相似度有意义吗？**
意义不大。因为这时候就算再计算精确的向量相似度，也只是在经过转换后的向量空间进行比较，因为这个空间比较“通用”，必定有所损失，无法在某种程度上准确表示所有的向量。

**精排模型为什么准呢？**
如前面说的，Bi-Encoder必须将所有的文档都映射到一个向量中，这个过程会丢失信息。而且，检索时query和已有的向量是没有交互的，是离线的状态，只是通过额外的相似度计算方法得到比较相似的向量，对query来说，缺乏必要的上下文信息。

而刚好精排模型是同时对两个句子进行编码的，这时候对query来说会含有上下文信息，而且从原始空间映射到隐空间是一个句子对而不是单独的句子，也更保证最终得到的相似度包含用户查询的文档信息。但是相对的，精排模型的结构决定了它的计算是实时的，而且计算量会比单纯的相似度计算大不少。

## 现有的精排模型

现有开源的Reranker模型已经非常多了，国内比较出门的有Jina-8k、bge-reranker以及bce-reranker等，且更新得非常快，目前看起来就是哪个最新用哪个，基本差异不大。值得一提的是Jina的模型是基于Alibi改进的注意力机制，所以能支持8K的上下文窗口，而bce本身只支持512k的上下文窗口，但是对较长的上下文进行切分，并且以其中一段最好的得分作为最终的相似度。bge模型没看过源码，等以后有时间针对这几个模型再研究一番。

# 总结

虽然目前二阶段方法用来提升RAG的性能表现越来越受到关注，但是具体来看，其中所含的技术都是早就有的内容。Cross-Encoder这种架构在当时显得比较鸡肋，只能用来比较句子的相似度，甚至无法输出向量，在大部分自然语言处理场景中都不受待见，谁能想到在如今又焕发生机了呢？
